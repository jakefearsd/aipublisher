package com.jakefear.aipublisher.output;

import com.jakefear.aipublisher.config.OutputProperties;
import com.jakefear.aipublisher.document.FinalArticle;
import com.jakefear.aipublisher.document.PublishingDocument;
import com.jakefear.aipublisher.util.PageNameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Service for writing wiki articles to the filesystem.
 * Handles file generation, existing page discovery, and JSPWiki Markdown formatting.
 */
@Service
public class WikiOutputService {

    private static final Logger log = LoggerFactory.getLogger(WikiOutputService.class);

    private final OutputProperties outputProperties;

    public WikiOutputService(OutputProperties outputProperties) {
        this.outputProperties = outputProperties;
    }

    /**
     * Write a completed document to the output directory.
     *
     * @param document The document to write
     * @return The path to the written file
     * @throws IOException if writing fails
     */
    public Path writeDocument(PublishingDocument document) throws IOException {
        FinalArticle article = document.getFinalArticle();
        if (article == null) {
            throw new IllegalStateException("Document has no final article to write");
        }

        Path outputDir = ensureOutputDirectory();
        String filename = generateFilename(document.getPageName());
        Path outputPath = outputDir.resolve(filename);

        String content = formatForOutput(article);

        Files.writeString(outputPath, content, StandardCharsets.UTF_8);

        log.info("Wrote article to {}: {} words, quality score {}",
                outputPath, article.estimateWordCount(), article.qualityScore());

        return outputPath;
    }

    /**
     * Discover existing wiki pages in the output directory.
     * These can be linked to from new articles using [PageName]() syntax.
     *
     * @return Set of existing page names (without .md extension)
     */
    public Set<String> discoverExistingPages() {
        Path outputDir = outputProperties.getDirectoryPath();

        if (!Files.exists(outputDir)) {
            log.debug("Output directory does not exist yet: {}", outputDir);
            return Set.of();
        }

        try (Stream<Path> files = Files.list(outputDir)) {
            Set<String> pages = files
                    .filter(Files::isRegularFile)
                    .map(Path::getFileName)
                    .map(Path::toString)
                    .filter(name -> name.endsWith(outputProperties.getFileExtension()))
                    .map(this::removeExtension)
                    .collect(Collectors.toSet());

            log.debug("Discovered {} existing pages in {}", pages.size(), outputDir);
            return pages;
        } catch (IOException e) {
            log.warn("Failed to discover existing pages: {}", e.getMessage());
            return Set.of();
        }
    }

    /**
     * Get the list of existing pages as a sorted list.
     *
     * @return Sorted list of existing page names
     */
    public List<String> getExistingPagesList() {
        return discoverExistingPages().stream()
                .sorted()
                .collect(Collectors.toList());
    }

    /**
     * Check if a page already exists in the output directory.
     *
     * @param pageName The page name to check (without extension)
     * @return true if the page exists
     */
    public boolean pageExists(String pageName) {
        Path outputDir = outputProperties.getDirectoryPath();
        String filename = generateFilename(pageName);
        return Files.exists(outputDir.resolve(filename));
    }

    /**
     * Generate the filename for a page.
     *
     * @param pageName The page name (should be CamelCase)
     * @return The filename with extension
     */
    public String generateFilename(String pageName) {
        return PageNameUtils.toCamelCaseOrDefault(pageName, "UnnamedPage") + outputProperties.getFileExtension();
    }

    /**
     * Format the final article content for JSPWiki output.
     * The article content should already be properly formatted by the editor,
     * so this mainly ensures consistent line endings and optional metadata comments.
     *
     * @param article The final article
     * @return Formatted content ready to write
     */
    public String formatForOutput(FinalArticle article) {
        StringBuilder sb = new StringBuilder();

        // Optional: Add metadata as HTML comment at top (useful for debugging)
        // JSPWiki will ignore these comments
        sb.append("<!-- \n");
        sb.append("  Generated by AI Publisher\n");
        sb.append("  Title: ").append(article.getTitle()).append("\n");
        sb.append("  Quality Score: ").append(String.format("%.2f", article.qualityScore())).append("\n");
        if (article.editSummary() != null && !article.editSummary().isBlank()) {
            sb.append("  Edit Summary: ").append(article.editSummary()).append("\n");
        }
        sb.append("-->\n\n");

        // Main content
        sb.append(article.markdownContent());

        // Ensure file ends with newline
        if (!article.markdownContent().endsWith("\n")) {
            sb.append("\n");
        }

        return sb.toString();
    }

    /**
     * Ensure the output directory exists, creating it if necessary.
     *
     * @return Path to the output directory
     * @throws IOException if directory creation fails
     */
    public Path ensureOutputDirectory() throws IOException {
        Path outputDir = outputProperties.getDirectoryPath();

        if (!Files.exists(outputDir)) {
            Files.createDirectories(outputDir);
            log.info("Created output directory: {}", outputDir);
        }

        return outputDir;
    }

    /**
     * Remove the file extension from a filename.
     */
    private String removeExtension(String filename) {
        String ext = outputProperties.getFileExtension();
        if (filename.endsWith(ext)) {
            return filename.substring(0, filename.length() - ext.length());
        }
        return filename;
    }

    // Getters for testing
    public OutputProperties getOutputProperties() {
        return outputProperties;
    }
}
